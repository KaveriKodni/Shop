 AWAIT IN JS
 * The await keyword is used in JavaScript to pause the execution of an asynchronous function until a Promise is settled (either resolved or rejected).

# When you use await with fetch(), it waits for the fetch() Promise to resolve, meaning it waits until the HTTP request completes and the response is received.

 const response = await fetch('http://127.0.0.1:8000/Flower/');
            const flowers = await response.json();

# After receiving the response, you call response.json(), which also returns a Promise that resolves to the JSON data from the response..

HOW URL WORKS
<form action="{% url 'contact' %}" method="POST">
    {% csrf_token %}
    <!-- Form fields go here -->
</form>
* Te action="{% url 'contact' %}" sets the URL to which the form will submit the data.
* The {% url 'contact' %} template tag dynamically generates the URL for the contact view
 based on the URL configuration in Django (urls.py).
 It corresponds to the path you’ve defined with the name contact.
* method="POST" tells the browser to send the form data as a POST request. POST requests are commonly used for submitting data to a server.
* CSRF Token:
   Django requires this token in POST requests to ensure that the form submission is coming from a trusted source (your own website).

* Form Submission Process
   Step-by-step Flow:
        User Fills Out the Form:

        The user enters their name, email, and message in the respective fields.
        Form Submission:

        When the user clicks the "Submit" button, the form sends a POST request to the URL generated by {% url 'contact' %}.
        Data Sent to Django View:

        The form data is included in the request body and sent to the backend.
        The Django view associated with the contact URL processes the incoming data.

When U Want to Connect html form file to database  fields name should matches with name attribute of input tag

USE OF
type="text/javascript"
Historical Context: In HTML5, the type attribute is optional and defaults to text/javascript. So, you typically don’t need to specify it unless you're using a different scripting language.


# ABOUT SELECT_RELATED()
* In Django, when you use select_related('flower'), you are leveraging the power of the ORM (Object-Relational Mapping)
to optimize your database queries by performing a SQL join and including the related Flower data in the query result.
* select_related() is used for optimizing queries by performing a SQL JOIN to fetch related objects in a single query.
* when accessing a related object (like order.flower), Django would issue an additional query to the Flower table. Using select_related(), Django performs a single query to fetch both the Order and its related Flower object.

* if we not used select_related()
   then sql works like this
     SELECT "flower"."id", "flower"."name", "flower"."color"
     FROM "flower"
     WHERE "flower"."id" = 1

* using select_related
        SELECT "order"."id", "order"."quantity", "order"."date","flower"."id",
        "flower"."name", "flower"."color"
        FROM "order"  INNER JOIN "flower"
        ON "order"."flower_id" = "flower"."id";

PARSE(JSON.parse(...))
* This method takes a JSON string and converts it into a JavaScript object.

TESTING MOBILE NUMBER
=>  /^\d{10}$/ checks if the mobileNumber consists of exactly 10 digits, with no extra characters or spaces.
* .test(mobileNumber): The .test() method checks if the mobileNumber matches the pattern described by the regular
expression.
* regex.test(string) => The .test() method is a function in JavaScript used to check if
a string matches a regular expression pattern.

 const response = await fetch("http://127.0.0.1:8000/Order/", {
                        method: "POST",
                        headers: {
                            "Content-Type": "application/json",
                        },
                        body: JSON.stringify(orderData) // Send the prepared order data
                    });

The fetch function is used to make an HTTP request to the server at "http://127.0.0.1:8000/Order/". This URL should point to an API endpoint that handles order submissions.
method: "POST": Specifies that this is a POST request (used for sending data).
headers: Informs the server that the data being sent is JSON by setting the Content-Type to "application/json".
body: JSON.stringify(orderData): The orderData object is converted into a JSON string so it can be transmitted in the request body.

# why name should be same as field name in input
When you submit a form using the GET method, the form's input fields are converted into URL query parameters. The key for each query parameter comes from the name attribute of the input field.

# PAGINATOR
has_previous, has_next, and other similar attributes are built-in methods provided by Django's Paginator class.

has_previous: Returns True if there is a previous page available (i.e., if the current page is not the first page).
has_next: Returns True if there is a next page available (i.e., if the current page is not the last page).
number: The current page number.
paginator: The Paginator instance associated with the current page object.
previous_page_number: Returns the page number of the previous page if it exists; otherwise, it raises an exception.
next_page_number: Returns the page number of the next page if it exists; otherwise, it raises an exception.
paginator.page_range: A range of all the available page numbers.

{% if flowers.has_previous %}
<li class="page-item">
    <a class="page-link"
       href="?page={{ flowers.previous_page_number }}{% if get_name %}&name={{ get_name }}{% endif %}">Previous</a>
</li>
{% endif %}

?page={{ flowers.previous_page_number }} sets the page query parameter to the previous page's number.









SHOP_PAGE SCRIPTS
<!--
document.addEventListener("DOMContentLoaded", function () {-->
<!--            fetchFlowers();-->
<!--        });-->
<!--     let flowers=[]-->
<!--         async function fetchFlowers() {-->
<!--        // Extract the category name from the URL query parameters-->
<!--        const urlParams = new URLSearchParams(window.location.search);-->
<!--        const categoryName = urlParams.get('name'); // 'name' corresponds to ?name=category in the URL-->

<!--        let url=``-->
<!--        if (categoryName)-->
<!--                url = `http://127.0.0.1:8000/Flower/?name=${categoryName}`;-->
<!--        else-->
<!--                url=`http://127.0.0.1:8000/Flower/`-->

<!--        try {-->
<!--            const response = await fetch(url);-->
<!--            if (!response.ok) {-->
<!--                throw new Error(`HTTP error! status: ${response.status}`);-->
<!--            }-->

<!--            flowers = await response.json();-->
<!--            const container = document.getElementById('flowers-container');-->
<!--            container.innerHTML = '';  // Clear current flower list-->

<!--            flowers.forEach(flower => {-->
<!--                container.innerHTML += `-->
<!--                    <div class="col-md-4 my-4">-->
<!--                        <div class="card flower-card h-100">-->
<!--                            <img src="${flower.image_url}" class="card-img-top img-fluid " alt="${flower.name}">-->
<!--                            <div class="card-body ">-->
<!--                                <h5 class="card-title">${flower.name}</h5>-->
<!--                                <p class="card-text">${flower.description}</p>-->
<!--                                <p><strong>Price: Rs ${flower.price}</strong></p>-->
<!--                                <button class="btn btn-primary add-to-cart" onclick='addToCart(${flower.id})'>Add to Cart</button>-->
<!--                            </div>-->
<!--                        </div>-->
<!--                    </div>-->
<!--                `;-->
<!--            });-->
<!--        } catch (error) {-->
<!--            console.error('Error fetching flowers:', error);-->
<!--            alert('Failed to load flowers. Please try again later.');-->
<!--        }-->
<!--    }-->


